{"version":3,"sources":["../src/EventEmitter.js"],"names":["TypeError","some","Object","keys","forEach","push","defineProperties","value","writable","enumerable","configurable","defaultMaxListeners","Math","max","hasListenersForEvent","type","listener","removeListener","call","length","maxListenersWarnedOnce","warn","toString","splice","addListener","map","validateEventArgument","validateListenerArgument","findIndex","assign","keysOfDefinedProperties","emitter","console","Date","now","exports"],"mappings":"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","file":"EventEmitter.js","sourcesContent":["/**\n * A node.js like event emitter that works in the browser (IE 9+).\n * This module adheres to same interface as node's events' equivalent.\n * @author Jason Pollman <jasonjpollman@gmail.com>\n * @since 3/12/18\n */\n\nconst log = console;\n\n// Since IE doesn't support symbols\nconst timestamp = Date.now();\nconst events = `__EVENT_EMITTER_EVENTS_${timestamp}__`;\nconst maxListeners = `__EVENT_EMITTER_MAX_LISTENERS_${timestamp}__`;\n\n/**\n * Returns an object's \"listener\" property.\n * @param {object} target The target object to return the \"listener\" property of.\n * @returns {function} The object's listener property.\n */\nconst getListenerProperty = ({ listener }) => listener;\n\n/**\n * Validates that the given value is a string or symbol and throws if not.\n * @param {any} value The value to inspect.\n * @returns {undefined}\n */\nexport function validateEventArgument(value) {\n  if (typeof value !== 'string' && typeof value !== 'symbol') {\n    throw new TypeError(\n      'Argument for parameter \"event\" must be a string or symbol.',\n    );\n  }\n}\n\n/**\n * Validates that the given value is a function and throws if not.\n * @param {any} value The value to inspect.\n * @returns {undefined}\n */\nexport function validateListenerArgument(value) {\n  if (typeof value !== 'function') {\n    throw new TypeError(\n      'Argument for parameter \"listener\" must be a function.',\n    );\n  }\n}\n\n/**\n * Array.prototype.findIndex isn't supported by IE.\n * @param {Array} collection The array to find the index value using the given callback.\n * @param {function} iteratee The callback to invoke for each element in the array.\n * @returns {number} The first index of the iteratee value that returns true (or -1).\n */\nexport function findIndex(collection, iteratee) {\n  let index = -1;\n\n  collection.some((value, key) => {\n    if (!iteratee(value, key, collection)) return false;\n    index = key;\n    return true;\n  });\n\n  return index;\n}\n\n/**\n * IE doesn't support Object.assign.\n * @param {object} assignee The object to assign to.\n * @param {object} properties The collection of properties to assign to the object.\n * @export\n */\nexport function assign(assignee, properties) {\n  const target = assignee;\n\n  Object.keys(properties).forEach((property) => {\n    target[property] = properties[property];\n  });\n\n  return target;\n}\n\n/**\n * Returns all the keys of an object who's value isn't `undefined`.\n * @param {object} object The object to get the keys of.\n * @returns {Array<string>} The set of keys who's values are not equal to `undefined`.\n * @export\n */\nexport function keysOfDefinedProperties(object) {\n  const keys = [];\n\n  Object.keys(object).forEach((key) => {\n    if (object[key] !== undefined) keys.push(key);\n  });\n\n  return keys;\n}\n\n/**\n * Creates a new EventEmitter class that extends the given `Target` class..\n * @param {function} Target The target class to extend.\n * @returns {function} The EventEmitter class that extends `Target`.\n * @export\n */\nexport function emitter(Target = class {}) {\n  return class EventEmitter extends Target {\n    /**\n     * The default number of \"maxListeners\".\n     * @memberof EventEmitter\n     * @static\n     */\n    static get defaultMaxListeners() {\n      return typeof EventEmitter[maxListeners] === 'number' ? EventEmitter[maxListeners] : 10;\n    }\n\n    /**\n     * Sets the default number of \"maxListeners\".\n     * @memberof EventEmitter\n     * @static\n     */\n    static set defaultMaxListeners(n) {\n      EventEmitter[maxListeners] = Math.max(Number(n) || 0, 0);\n    }\n\n    /**\n     * Creates an instance of EventEmitter.\n     * @memberof EventEmitter\n     */\n    constructor(...args) {\n      super(...args);\n\n      Object.defineProperties(this, {\n        [events]: {\n          value: {},\n          writable: true,\n          enumerable: false,\n          configurable: false,\n        },\n        [maxListeners]: {\n          value: EventEmitter.defaultMaxListeners,\n          writable: true,\n          enumerable: false,\n          configurable: false,\n        },\n      });\n    }\n\n    /**\n     * True if the EventEmitter instance contains listeners for the given event.\n     * @param {any} event The name of the event to assert existence.\n     * @returns {boolean} True if it has listeners for the given event, false otherwise.\n     */\n    hasListenersForEvent(event) {\n      return Boolean(this[events][event]);\n    }\n\n    /**\n     * @returns {number} This EventEmitter's `maxListeners` property.\n     * @memberof EventEmitter\n     */\n    getMaxListeners() {\n      return this[maxListeners];\n    }\n\n    /**\n     * Sets the `maxListener` count.\n     * @param {number} n The value to set the max listener count to.\n     * @returns {EventEmitter} The current event emitter instance for chaining.\n     * @memberof EventEmitter\n     */\n    setMaxListeners(n) {\n      this[maxListeners] = Math.max(Number(n) || 0, 0);\n      return this;\n    }\n\n    /**\n     * Emits (\"triggers\") an event, calling all of the registered listeners.\n     * @param {string|symbol} event The event to emit.\n     * @param {...any} args The arguments list to invoke to each listener with.\n     * @returns {EventEmitter} The current event emitter instance for chaining.\n     * @memberof EventEmitter\n     */\n    emit(event, ...args) {\n      if (!this.hasListenersForEvent(event)) return this;\n\n      [...this[events][event]].forEach(({ type, listener }) => {\n        if (type === 'once') this.removeListener(event, listener);\n        listener.call(this, ...args);\n      });\n\n      return this;\n    }\n\n    /**\n     * Adds a \"persistent\" event listener.\n     * @param {string|symbol} event The event to listen on.\n     * @param {function} listener The callback to invoke when \"event\" is emitted.\n     * @returns {EventEmitter} The current event emitter instance for chaining.\n     * @memberof EventEmitter\n     */\n    addListener(event, listener, type = 'on') {\n      validateEventArgument(event);\n      validateListenerArgument(listener);\n\n      if (!this.hasListenersForEvent(event)) this[events][event] = [];\n\n      const listeners = this[events][event];\n      listeners.push({ type, listener });\n\n      // If the user has reached the \"maxListeners\" count print a warning.\n      // This will only trigger once, so subsequent \"addListener\" calls\n      // won't spam the console.\n      if (listeners.length > this[maxListeners] && !this.maxListenersWarnedOnce) {\n        this.maxListenersWarnedOnce = true;\n\n        log.warn(\n          `Possible EventEmitter memory leak detected. ${listeners.length} \"${event.toString()}\" ` +\n          'listeners added. Use EventEmitter#setMaxListeners to increase this limit.',\n        );\n      }\n\n      return this;\n    }\n\n    /**\n     * Removes a listener from the specified event.\n     * @param {string|symbol} event The event to remove the listener from.\n     * @returns {EventEmitter} The current event emitter instance for chaining.\n     * @memberof EventEmitter\n     */\n    removeListener(event, listener) {\n      validateEventArgument(event);\n\n      // Event doesn't exist, or nothing valid to remove.\n      if (!this.hasListenersForEvent(event) || typeof listener !== 'function') return this;\n\n      const listeners = this[events][event];\n      const index = findIndex(listeners, wrapper => wrapper.listener === listener);\n\n      if (index !== -1) {\n        listeners.splice(index, 1);\n        if (!listeners.length) this[events][event] = undefined;\n      }\n\n      return this;\n    }\n\n    /**\n     * Removes all listeners for all events or the one specified by \"event\".\n     * @param {string|symbol=} event The event to remove the listeners from.\n     * @returns {EventEmitter} The current event emitter instance for chaining.\n     * @memberof EventEmitter\n     */\n    removeAllListeners(event) {\n      if (event !== null && event !== undefined) {\n        this[events][event] = undefined;\n      } else {\n        this[events] = {};\n      }\n\n      return this;\n    }\n\n    /**\n     * Adds a \"one time\" listener.\n     * @param {string|symbol} event The event to listen on.\n     * @param {function} listener The callback to invoke when \"event\" is emitted.\n     * @returns {EventEmitter} The current event emitter instance for chaining.\n     * @memberof EventEmitter\n     */\n    once(event, listener) {\n      return this.addListener(event, listener, 'once');\n    }\n\n    /**\n     * Returns this listener count for the given event.\n     * @param {string|symbol} event The name of the event to get the listener count of.\n     * @returns {number} The number of registered events for \"event\".\n     * @memberof EventEmitter\n     */\n    listenerCount(event) {\n      return (this[events][event] || []).length;\n    }\n\n    /**\n     * Returns a shallow copy of the listeners for the given event.\n     * @param {string|symbol} event The name of the event to get the listeners of.\n     * @returns {Array<function>} A shallow copy of the listeners for \"event\".\n     * @memberof EventEmitter\n     */\n    listeners(event) {\n      return (this[events][event] || []).map(getListenerProperty);\n    }\n\n    /**\n     * @returns {Array<string|symbol>} The list of events which have registered listeners attached.\n     * @memberof EventEmitter\n     */\n    eventNames() {\n      return keysOfDefinedProperties(this[events]);\n    }\n\n    /**\n     * An alias for EventEmitter#addListener\n     * @memberof EventEmitter\n     * @readonly\n     */\n    get on() {\n      return this.addListener;\n    }\n\n    /**\n     * An alias for EventEmitter#removeListener\n     * @memberof EventEmitter\n     * @readonly\n     */\n    get off() {\n      return this.removeListener;\n    }\n  };\n}\n\n// Make the default export a function (the base EventEmitter class) and assign all\n// exports to the class as properties. This makes the \"exports\" a bit more user\n// friendly in the browser environment.\nmodule.exports = assign(emitter(), exports);\n\n"]}